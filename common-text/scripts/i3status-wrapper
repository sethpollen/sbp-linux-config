#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Prefixes each i3status line with some custom information. Adapted from
#   http://code.stapelberg.de/git/i3status/tree/contrib/wrapper.py
#
# To use it, ensure your ~/.i3status.conf contains this line:
#     output_format = "i3bar"
# in the 'general' section.
# Then, in the 'bar' section of your ~/.i3/config, use:
#     status_command i3status-wrapper

import sys
import json
import mailbox
import math
import subprocess
import threading
import re
import string
import os
import os.path
import time
import datetime

import netusage
import backlight
import numformat
import powersupply

CPU_HISTORY_LEN = 12

RED = '#FF0000'
YELLOW = '#FFFF00'
GREEN = '#00FF00'
BLUE = '#3333FF'
LIGHT_BLUE = '#ADFFF8'
CYAN = '#00FFFF'
GRAY = '#9F9F9F'

HOME = os.getenv('HOME')
assert len(HOME) > 0

light = backlight.Backlight()
netStats = netusage.Stats()
# Only refresh power supply stats every 6 seconds. Compute the power drain
# rate over a 1-minute interval.
powerSupplyStats = powersupply.HistoricalStatsRefresher(6, 60)


def readLine(f):
  """ Reads one line of text from file 'f'. """
  # Try reading a line, removing any extra whitespace.
  try:
    line = f.readline().strip()
    # This method is used to read text printed by i3status and i3bar. When these
    # programs send EOF or an empty line, it means we should exit.
    if not line:
      sys.exit(3)
    return line
  # Exit on ctrl-C.
  except KeyboardInterrupt:
    sys.exit()


def printLine(message):
  """ Non-buffered printing to stdout. """
  sys.stdout.write(message + '\n')
  sys.stdout.flush()


def replaceYesNoWithPlusMinus(text):
  """ Replaces "yes" with "+" and "no" with "-" to save space. """
  text = string.replace(text, ': yes', '+')
  text = string.replace(text, ': no', '-')
  text = string.replace(text, ':', '')
  return text


def formatByteRate(byteRate):
  """ Formats a network byte rate into three characters. """
  return numformat.shortBytes(byteRate, 1)


def ensureLeadingSpace(text):
  """ For unknown reasons, i3status sometimes ignores leading spaces present
  in .i3status.conf. So sometimes we have to add them back in here.
  """
  if text.startswith(' '):
    return text
  return ' ' + text


# Pattern for matching dates.
datePattern = re.compile(r' [0-9][0-9]\-[0-9][0-9] ')

def service_i3status():
  """ Runs i3status as a subprocess and passes the output to stdout, making
  some modifications to add cool features that i3status doesn't support.
  """
  # Run i3status and capture its output.
  i3status = subprocess.Popen("exec-from-i3 i3status", stdout=subprocess.PIPE,
                              # Explicitly drop stderr so it doesn't
                              # interfere with real output.
                              stderr=open('/dev/null', 'w'),
                              shell=True).stdout

  # Keep a little history of CPU usages to display in a bar graph. This history
  # is actually just a string of bar-graph characters.
  cpuGraph = numformat.roundToVerticalBar(0) * CPU_HISTORY_LEN

  # The first line from i3status is the version header. Modify the header
  # to enable click events, and then send it out to i3bar.
  versionHeader = json.loads(readLine(i3status))
  versionHeader['click_events'] = True
  printLine(json.dumps(versionHeader))

  # The second line contains the start of the infinite array; just pass it
  # through to i3bar.
  printLine(readLine(i3status))
  
  linesPrinted = 0
  while True:
    prefix, line = '', readLine(i3status)

    # Ignore comma at start of lines.
    if line.startswith(','):
      prefix, line = ',', line[1:]

    try:
      j = json.loads(line)
    except ValueError as e:
      # i3status sometimes spits out spurious log lines like
      #   i3status: PulseAudio: OK
      # And somehow these are getting into the stdout which this script reads.
      # So I have logic here to explicitly ignore lines which don't parse as
      # JSON. When we get one of those lines, just skip it and wait for the
      # next line.
      continue

    netStats.update()

    # Track the indices of the sections.
    sectionIndices = {}

    # Dress up the JSON for specific sections.
    for index, entry in enumerate(j):
      name = entry['name']
      text = entry['full_text']
      sectionIndices[name] = index

      if name == 'volume' or name == 'battery':
        entry['full_text'] = ensureLeadingSpace(replaceYesNoWithPlusMinus(
            numformat.replacePercentageWithBar(text)))

      elif name == 'disk_info':
        entry['color'] = GRAY

      elif name == 'wireless':
        wirelessUp = ': no ' not in text
        text = replaceYesNoWithPlusMinus(
            numformat.replacePercentageWithBar(text))
        if wirelessUp:
          wirelessStats = netStats.interfaces[netusage.WIRELESS_INTERFACE]
          text = u'%s%s↓ %s↑ ' % (
              text,
              formatByteRate(wirelessStats.rxBytes.rate),
              formatByteRate(wirelessStats.txBytes.rate))
        entry['full_text'] = text

      elif name == 'ethernet':
        ethernetUp = ': no ' not in text
        text = replaceYesNoWithPlusMinus(text)
        # If gigabit ethernet is not enabled, set an annoying color.
        gigabit = '1000 Mbit/s' in text
        text = string.replace(text, ' 1000 Mbit/s', '')
        if ethernetUp:
          ethernetStats = netStats.interfaces[netusage.ETHERNET_INTERFACE]
          if not gigabit:
            entry['color'] = YELLOW
          text = u'%s%s↓ %s↑ ' % (
              text,
              formatByteRate(ethernetStats.rxBytes.rate),
              formatByteRate(ethernetStats.txBytes.rate))
        entry['full_text'] = text

      elif name == 'cpu_usage':
        # Parse the CPU percentage and add it to the rolling list.
        cpuBar = numformat.roundToVerticalBar(
            float(numformat.stripNonDigits(text)) * 0.01)
        cpuGraph = cpuGraph[1:] + cpuBar
        # Don't allow the width to change. Always use 2 digits for the
        # percentage.
        if text == '100% ':
          text = '99% '
        # Append the graph to the displayed text.
        entry['full_text'] = ' ' + cpuGraph + numformat.LEFT_BAR + text

      elif name == 'time':
        # Strip unnecessary leading zeros from day and month.
        m = re.search(datePattern, text)
        if m:
          dateText = m.group(0)
          shortDateText = string.replace(dateText, ' 0', ' ')
          shortDateText = string.replace(shortDateText, '-0', '-')
          entry['full_text'] = string.replace(text, dateText, shortDateText)
          entry['color'] = YELLOW

    # Insert additional sections into the json.

    # Battery monitor.
    battStats = powerSupplyStats.get()
    if battStats.numBatteries > 0:
      battEntry = { 'name' : 'battery',
                    'instance' : 'all' }

      battFill = battStats.batteryCharge / battStats.batteryCapacity
      battFillGraph = (
          numformat.RIGHT_BAR +
          numformat.roundToVerticalBar(
              battStats.batteryCharge / battStats.batteryCapacity) +
          numformat.LEFT_BAR)

      if battStats.ac:
        battEntry['full_text'] = ' AC%s' % battFillGraph
        battEntry['color'] = BLUE
      elif battStats.batteryPower < 2:
        # If power is less than 2 W, don't try to compute remaining battery
        # life.
        battEntry['full_text'] = (' BAT%s%dW ' %
            (battFillGraph, battStats.batteryPower))
      else:
        secondsRemaining = battStats.batteryCharge / battStats.batteryPower
        hoursRemaining = secondsRemaining / 3600.0
        battEntry['full_text'] = (' BAT%s%.1fhr %dW ' %
            (battFillGraph, hoursRemaining, battStats.batteryPower))

      if battFill < 0.1:
        battEntry['color'] = RED
      elif battFill < 0.2:
        battEntry['color'] = YELLOW

      # The battery status should go just before the CPU monitor, which
      # is always in the third-rightmost position.
      j.insert(len(j) - 3, battEntry)

    # For brightness, only add the brightness indicator if getBrightness()
    # returns a non-error value.
    brightnessFraction = light.getBrightness()
    if brightnessFraction >= 0:
      j.insert(0, {
        'full_text' : u' ☼%s%s%s' % (
            numformat.RIGHT_BAR,
            numformat.roundToVerticalBar(brightnessFraction),
            numformat.LEFT_BAR),
        'name' : 'backlight',
        'instance' : '0'})

    # Add an unread-mail indicator if there are any unread messages in the
    # local mailbox.
    box = mailbox.Maildir(os.path.join(HOME, 'Maildir'))
    if len(box) > 0:
      j.insert(0, {
        'full_text' : u' %d [M] ' % len(box),
        'name' : 'maildir',
        'instance' : '0',
        'color' : YELLOW})
      
    # Add a blinking heart icon to show that we are actively running.
    j.insert(0, {
      'full_text' : u' ♥ ' if linesPrinted % 2 == 0 else '   ',
      'name' : 'spinner',
      'instance' : 0,
      'color' : GRAY})

    # Echo back new encoded json.
    printLine(prefix + json.dumps(j))
    linesPrinted += 1


def service_stdin():
  """ Reads click event lines from stdin. These come from i3bar. """
  # The first line contains the start of the infinite array; ignore it.
  readLine(sys.stdin)

  # When starting programs in response to clicks, suppress their output and
  # don't wait for them to finish.
  def call(program):
    devnull = open('/dev/null', 'r')
    subprocess.Popen(program, stdout=devnull, stderr=devnull)

  while True:
    line = readLine(sys.stdin)

    # Ignore comma at start of lines.
    if line.startswith(','):
      line = line[1:]
    j = json.loads(line)
    name = j['name']

    # If we wanted to respond to click events, we could examine 'name' here.


if __name__ == '__main__':
  # For an unknown reason, i3status doesn't work properly if started too early
  # during the login sequence. When this problem occurs, i3status prints out
  # only the header lines, but no actual data. To avoid triggering this problem,
  # we wait for a few seconds before spawning the i3status process.

  # Spawn a separate thread to service click events from i3bar.
  childThread = threading.Thread(target=service_stdin)
  childThread.start()
  service_i3status()
  # service_i3status should never return, so this statement is somewhat
  # pointless. I include it for completeness.
  childThread.join()

