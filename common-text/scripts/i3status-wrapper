#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Prefixes each i3status line with some custom information. Adapted from
#   http://code.stapelberg.de/git/i3status/tree/contrib/wrapper.py
#
# To use it, ensure your ~/.i3status.conf contains this line:
#     output_format = "i3bar"
# in the 'general' section.
# Then, in the 'bar' section of your ~/.i3/config, use:
#     status_command i3status-wrapper

import sys
import json
import mailbox
import math
import subprocess
import threading
import re
import string
import os
import os.path
import time
import datetime
import Queue

import netusage
import backlight
import numformat
import powersupply

CPU_HISTORY_LEN = 10

RED = '#FF0000'
YELLOW = '#FFFF00'
GREEN = '#00FF00'
BLUE = '#3333FF'
LIGHT_BLUE = '#ADFFF8'
CYAN = '#00FFFF'
GRAY = '#9F9F9F'
WHITE = '#FFFFFF'

HOME = os.getenv('HOME')
assert len(HOME) > 0

light = backlight.Backlight()
netStats = netusage.Stats()
# Only refresh power supply stats every 6 seconds. Compute the power drain
# rate over a 1-minute interval.
powerSupplyStats = powersupply.HistoricalStatsRefresher(6, 60)


def readLine(f):
  """ Reads one line of text from file 'f'. """
  # Try reading a line, removing any extra whitespace.
  try:
    line = f.readline().strip()
    # This method is used to read text printed by i3status and i3bar. When these
    # programs send EOF or an empty line, it means we should exit.
    if not line:
      sys.exit(3)
    return line
  # Exit on ctrl-C.
  except KeyboardInterrupt:
    sys.exit()


def printLine(message):
  """ Non-buffered printing to stdout. """
  sys.stdout.write(message + '\n')
  sys.stdout.flush()


def replaceYesNoWithPlusMinus(text):
  """ Replaces "yes" with "+" and "no" with "-" to save space. """
  text = string.replace(text, ': yes', '+')
  text = string.replace(text, ': no', '-')
  text = string.replace(text, ':', '')
  return text


def formatByteRate(byteRate):
  """ Formats a network byte rate into three characters. """
  return numformat.shortBytes(byteRate, 1)


def ensureLeadingSpace(text):
  """ For unknown reasons, i3status sometimes ignores leading spaces present
  in .i3status.conf. So sometimes we have to add them back in here.
  """
  if text.startswith(' '):
    return text
  return ' ' + text


# Pattern for matching dates.
datePattern = re.compile(r' [0-9][0-9]\-[0-9][0-9] ')

def service_i3status():
  """ Runs i3status as a subprocess and passes the output to stdout, making
  some modifications to add cool features that i3status doesn't support.
  """
  # Run i3status and capture its output.
  i3status = subprocess.Popen("sbp-exec i3status", stdout=subprocess.PIPE,
                              # Explicitly drop stderr so it doesn't
                              # interfere with real output.
                              stderr=open('/dev/null', 'w'),
                              shell=True).stdout

  # Keep a little history of CPU usages to display in a bar graph. This history
  # is actually just a string of bar-graph characters.
  cpuGraph = numformat.roundToVerticalBar(0) * CPU_HISTORY_LEN

  heartBar = [u"⠋",	u"⠙",	u"⠹",	u"⠸",	u"⠼",	u"⠴",	u"⠦",	u"⠧",	u"⠇",	u"⠏"]
  heartPos = 0

  # The first line from i3status is the version header. Modify the header
  # to enable click events, and then send it out to i3bar.
  versionHeader = json.loads(readLine(i3status))
  versionHeader['click_events'] = True
  printLine(json.dumps(versionHeader))

  # The second line contains the start of the infinite array; just pass it
  # through to i3bar.
  printLine(readLine(i3status))

  ioQueue = Queue.Queue()

  # Pull in every update produced by i3status. Having this in a separate thread
  # allows us to decouple our display updates from i3status's data updates.
  def ioLoop():
    while True:
      l = readLine(i3status)

      # Ignore comma at start of lines.
      if l.startswith(','):
        prefix, line = ',', l[1:]
      else:
        prefix, line = '', l

      ioQueue.put((prefix, line))

  ioThread = threading.Thread(target=ioLoop)
  ioThread.start()

  prefix = None
  line = None

  lastFastUpdate = time.time()
  # CPU and network usage get updated every 2 seconds, even though our display
  # loop runs every 1 second.
  lastSlowUpdate = lastFastUpdate

  while True:
    # Throttle to 1 Hz.
    time.sleep(lastFastUpdate + 1 - time.time())
    lastFastUpdate = time.time()

    if prefix is None or line is None:
      # Block to get the first line.
      prefix, line = ioQueue.get()
    else:
      # Don't block.
      try:
        prefix, line = ioQueue.get_nowait()
      except Queue.Empty:
        pass

    # Grab the latest results from the I/O thread.
    p, l = prefix, line

    doSlowUpdate = False
    if lastFastUpdate - lastSlowUpdate >= 1.5:
      doSlowUpdate = True
      lastSlowUpdate = lastFastUpdate

    try:
      j = json.loads(l)
    except ValueError as e:
      # i3status sometimes spits out spurious log lines like
      #   i3status: PulseAudio: OK
      # And somehow these are getting into the stdout which this script reads.
      # So I have logic here to explicitly ignore lines which don't parse as
      # JSON. When we get one of those lines, just skip it and wait for the
      # next line.
      continue

    if doSlowUpdate:
      netStats.update()

    # Track the indices of the sections.
    sectionIndices = {}

    # Dress up the JSON for specific sections.
    for index, entry in enumerate(j):
      name = entry['name']
      text = entry['full_text']
      sectionIndices[name] = index

      if name == 'volume' or name == 'battery':
        entry['full_text'] = ensureLeadingSpace(replaceYesNoWithPlusMinus(
            numformat.replacePercentageWithBar(text)))

      elif name == 'disk_info':
        entry['color'] = GRAY
        # Use short SI prefixes.
        entry['full_text'] = string.replace(text, 'iB', '')

      elif name == 'wireless':
        wirelessUp = ': no ' not in text
        text = replaceYesNoWithPlusMinus(
            numformat.replacePercentageWithBar(text))
        if wirelessUp:
          wirelessStats = netStats.interfaces[netusage.WIRELESS_INTERFACE]
          text = u'%s%s↓ %s↑ ' % (
              text,
              formatByteRate(wirelessStats.rxBytes.rate),
              formatByteRate(wirelessStats.txBytes.rate))
        entry['full_text'] = text

      elif name == 'ethernet':
        ethernetUp = ': no ' not in text
        text = replaceYesNoWithPlusMinus(text)
        # If gigabit ethernet is not enabled, set an annoying color.
        gigabit = '1000 Mbit/s' in text
        text = string.replace(text, ' 1000 Mbit/s', '')
        if ethernetUp:
          ethernetStats = netStats.interfaces[netusage.ETHERNET_INTERFACE]
          if not gigabit:
            entry['color'] = YELLOW
          text = u'%s%s↓ %s↑ ' % (
              text,
              formatByteRate(ethernetStats.rxBytes.rate),
              formatByteRate(ethernetStats.txBytes.rate))
        entry['full_text'] = text

      elif name == 'cpu_usage':
        # Parse the CPU percentage and add it to the rolling list.
        if doSlowUpdate:
          cpuBar = numformat.roundToVerticalBar(
              float(numformat.stripNonDigits(text)) * 0.01)
          cpuGraph = cpuGraph[1:] + cpuBar
        # Don't allow the width to change. Always use 2 digits for the
        # percentage.
        if text == '100% ':
          text = '99% '
        # Append the graph to the displayed text.
        entry['full_text'] = ' ' + cpuGraph + numformat.LEFT_BAR + text
        # Don't show yellow or red for high CPU usage
        entry['color'] = WHITE

      elif name == 'time':
        # Strip unnecessary leading zeros from day and month.
        m = re.search(datePattern, text)
        if m:
          dateText = m.group(0)
          shortDateText = string.replace(dateText, ' 0', ' ')
          shortDateText = string.replace(shortDateText, '-0', '-')
          entry['full_text'] = string.replace(text, dateText, shortDateText)
          entry['color'] = YELLOW

    # Insert additional sections into the json.

    # Battery monitor.
    battStats = powerSupplyStats.get()
    if battStats.numBatteries > 0:
      battEntry = { 'name' : 'battery',
                    'instance' : 'all' }

      battFill = battStats.batteryCharge / battStats.batteryCapacity
      battFillGraph = (
          numformat.RIGHT_BAR +
          numformat.roundToVerticalBar(
              battStats.batteryCharge / battStats.batteryCapacity) +
          numformat.LEFT_BAR)

      if battStats.ac:
        battEntry['full_text'] = ' AC%s' % battFillGraph
        battEntry['color'] = BLUE
      elif battStats.batteryPower < 2:
        # If power is less than 2 W, don't try to compute remaining battery
        # life.
        battEntry['full_text'] = (' BAT%s%dW ' %
            (battFillGraph, battStats.batteryPower))
      else:
        secondsRemaining = battStats.batteryCharge / battStats.batteryPower
        hoursRemaining = secondsRemaining / 3600.0
        battEntry['full_text'] = (' BAT%s%.1fhr %dW ' %
            (battFillGraph, hoursRemaining, battStats.batteryPower))

      if battFill < 0.1:
        battEntry['color'] = RED
      elif battFill < 0.2:
        battEntry['color'] = YELLOW

      # The battery status should go just before the CPU monitor, which
      # is always in the third-rightmost position.
      j.insert(len(j) - 3, battEntry)

    # For brightness, only add the brightness indicator if getBrightness()
    # returns a non-error value.
    brightnessFraction = light.getBrightness()
    if brightnessFraction >= 0:
      j.insert(0, {
        'full_text' : u' ✻%s%s%s' % (
            numformat.RIGHT_BAR,
            numformat.roundToVerticalBar(brightnessFraction),
            numformat.LEFT_BAR),
        'name' : 'backlight',
        'instance' : '0'})

    # Add an unread-mail indicator if there are any unread messages in the
    # local mailbox.
    box = mailbox.Maildir(os.path.join(HOME, 'Maildir'))
    if len(box) > 0:
      j.insert(0, {
        'full_text' : u' %d [M] ' % len(box),
        'name' : 'maildir',
        'instance' : '0',
        'color' : YELLOW})
      
    # Add a subtle spinner to show that we are actively running.
    heartPos = heartPos + 1
    if heartPos >= len(heartBar):
      heartPos -= len(heartBar)
    j.insert(0, {
      'full_text' : ' ' + heartBar[heartPos] + ' ',
      'name' : 'spinner',
      'instance' : 0,
      'color' : GRAY})

    # Echo back new encoded json.
    printLine(p + json.dumps(j))


def service_stdin():
  """ Reads click event lines from stdin. These come from i3bar. """
  # The first line contains the start of the infinite array; ignore it.
  readLine(sys.stdin)

  # When starting programs in response to clicks, suppress their output and
  # don't wait for them to finish.
  def call(program):
    devnull = open('/dev/null', 'r')
    subprocess.Popen(program, stdout=devnull, stderr=devnull)

  while True:
    line = readLine(sys.stdin)

    # Ignore comma at start of lines.
    if line.startswith(','):
      line = line[1:]
    j = json.loads(line)
    name = j['name']

    # If we wanted to respond to click events, we could examine 'name' here.


if __name__ == '__main__':
  # Spawn a separate thread to service click events from i3bar.
  childThread = threading.Thread(target=service_stdin)
  childThread.start()
  service_i3status()

