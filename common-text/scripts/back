#!/usr/bin/env fish
#
# `back` is my lightweight tmux replacement. It gets much of its functionality
# from `dtach`, but additionally saves the output of detached commands for
# later viewing.

# -k or --kill may be passed to "join" to forcibly terminate the job with
# SIGTERM.
argparse --name=back 'k/kill' -- $argv
or exit

set home ~/.back
mkdir -p $home
or exit

set subcmds fork join ls

if test (count $argv) -lt 1
  echo "No subcommand. Try one of these:"
  echo "  $subcmds"
  exit 1
end
set subcmd $argv[1]
set argv $argv[2..-1]

if not contains $subcmd $subcmds
  echo "Unrecognized subcommand:" $subcmd
  exit 1
end

# ls: Print a newline-separated list of unjoined jobs. Usage:
#   back ls
if test $subcmd = "ls"
  # TODO: add a mode (flagged off when this is called for fish completions)
  # which stars any completed jobs which can now be joined.
  find $home -maxdepth 1 -path "$home/*" -printf "%f\n"
  exit
end

# All other commands take a job name.
if test (count $argv) -lt 1
  echo "Missing job name"
  exit 1
end
set job $argv[1]
set argv $argv[2..-1]

set job_home "$home/$job"
set output "$job_home/output"
set dtach dtach -n "$job_home/socket"

# fork: Spawn a new detached job. Usage:
#   back fork <job_name> <command...>
if test $subcmd = "fork"
  if test (count $argv) -lt 1
    echo "No command to run"
    exit 1
  end

  if not mkdir $job_home 2>/dev/null
    echo "Job name already in use:" $job
    exit 2
  end

  # TODO: special case back's own item in the prompt to show this job's name
  set prompt "sbp-prompt --width=$COLUMNS --output=fish_prompt"
  set echo_program "echo \"$argv\""
  # We wrap the program in fish twice. The inner fish call makes sure that
  # we don't get any weird syntax interaction with the command.
  set invoke "fish -c \"$argv\""
  set redirects "</dev/null >\"$output\" 2>&1"

  $dtach -E \
    fish -c "
      begin
        $prompt
        set_color $fish_color_command
        $echo_program
        set_color normal
        $invoke
        $prompt --exit_code=\$status --dollar=false
      end $redirects"
  exit
end

# The subcmd must be "join". It takes no more arguments.
if test (count $argv) -gt 0
  echo "Extra arguments:" $argv
  exit 1
end

# Join requires the job to exist (even if it has completed).
if not test -d $job_home
  echo "Job does not exist:" $job
  exit 2
end

# Obey the --kill flag.
if test -n "$_flag_kill"
  # Kill any dtach process pointed at our socket. There should be at most
  # one (the detached process itself).
  if pkill --full "$dtach"
    echo "Job killed:" $job
  else
    echo "Job already dead:" $job
  end
end

# We will only clean up the job if it exited before we show its output to the
# user.
set cleanup yes
if pgrep --full "$dtach" >/dev/null
  echo "Job still running:" $job
  set cleanup
end

# Tell less to show ANSI colors.
less --RAW-CONTROL-CHARS $output

if test -n "$cleanup"
  # TODO: killing the job quickly (before it starts writing output) can cause
  # this to fail. We shold pre-create the output file to avoid this.
  rm $output
  and rmdir $job_home
end
