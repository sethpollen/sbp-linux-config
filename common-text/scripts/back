#!/usr/bin/env fish
#
# `back` is my lightweight tmux replacement. It gets much of its functionality
# from `dtach`, but additionally saves the output of detached commands for
# later viewing.

# TODO: add completions

set home ~/.back
mkdir -p $home
or exit

set subcmds fork join ls kill peek

if test (count $argv) -lt 1
  echo "No subcommand. Try one of these:"
  echo "  $subcmds"
  exit 1
end
set subcmd $argv[1]
set argv $argv[2..-1]

if not contains $subcmd $subcmds
  echo "Unrecognized subcommand:" $subcmd
  exit 1
end

# ls: Print a newline-separated list of unjoined jobs. Usage:
#   back ls
if test $subcmd = "ls"
  find $home -maxdepth 1 -path "$home/*" -printf "%f\n"
  exit
end

# All other commands take a job name.
if test (count $argv) -lt 1
  echo "Missing job name"
  exit 1
end
set job $argv[1]
set argv $argv[2..-1]

set job_home "$home/$job"
set output "$job_home/output"
set dtach dtach -n "$job_home/socket"

# fork: Spawn a new detached job. Usage:
#   back fork <job_name> <command...>
if test $subcmd = "fork"
  if test (count $argv) -lt 1
    echo "No command to run"
    exit 1
  end

  if not mkdir $job_home 2>/dev/null
    echo "Job name already in use:" $job
    exit 2
  end

  # TODO: special case back's own item in the prompt to show this job's name
  set prompt "sbp-prompt --width=$COLUMNS --output=fish_prompt"
  set echo_program "echo \"$argv\""
  # We wrap the program in fish twice. The inner fish call makes sure that
  # we don't get any weird syntax interaction with the command.
  set invoke "fish -c \"$argv\""
  set redirects "</dev/null >\"$output\" 2>&1"

  $dtach -E \
    fish -c "
      begin
        $prompt
        set_color $fish_color_command
        $echo_program
        set_color normal
        $invoke
        $prompt --exit_code=\$status --dollar=false
      end $redirects"
  exit
end

# All other commands take no more arguments.
if test (count $argv) -gt 0
  echo "Extra arguments:" $argv
  exit 1
end

# All other commands require the job to exist.
if not test -d $job_home
  echo "Job does not exist:" $job
  exit 2
end

# kill: Forcibly terminate (via SIGTERM) a (potentially) running job and display
# any output it produced. Usage:
#   back kill <job_name>
if test $subcmd = "kill"
  if not pkill --full "$dtach"
    echo "Job already dead:" $job
  end

  # Jump to the join logic to display the output and clean up.
  set me (status filename)
  $me join $job
  exit
end

# Shows the program's output.
function show_output --no-scope-shadowing
  if test -f $output
    # Tell less to show ANSI colors.
    less --RAW-CONTROL-CHARS $output
  else
    echo "Job produced no output"
  end
end

# join: Clean up resources from a completed job, and show its output. Usage:
#   back join <job_name>
if test $subcmd = "join"
  if pgrep --full "$dtach" >/dev/null
    echo "Job still running:" $job
    exit 2
  end

  show_output

  rm $output
  and rmdir $job_home
  exit
end

# TODO: maybe combine join and peek into a command which joins if possible
# and otherwise just peeks while printing a warning.

# peek: Display output produced so far by a running or completed job. Do not
# clean up any resources. Usage:
#   back peek <job_name>
if test $subcmd = "peek"
  show_output
  exit
end

echo "SHOULD NEVER HAPPEN"
exit 99
